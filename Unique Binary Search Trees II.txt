/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; left = null; right = null; }
 * }
 */
public class Solution {
    public List<TreeNode> generateTrees(int n) {
        int start = 1; 
        int end = n;
        List<TreeNode> results = new ArrayList<TreeNode>();
        if ( n <= 0)
        {
            TreeNode aResult = null;
            results.add(aResult);
            return results;
        } // if not add "TreeNode aResult = null; results.add(aResult)", it will have runtime error.
        // input : 0
        // output: []
        // expected: [{}]
        // it means, we can generate a null tree from the given input??????????????????????!!!!!!!!!!!!!!!!!!!!!!!!!!
        // how to understand: the results, is a list of treenodes. 
        // so the content should be some treenode, whether it is null or not.
        // also, you can't do " TreeNode aResult = new TreeNode(); results.add(aResult) "
        // because, you don't have a TreeNode() constructor.
        
        results = generateTrees(start, end);
        return results;
    }
    
    public List<TreeNode> generateTrees(int start, int end) {
        List<TreeNode> results = new ArrayList<TreeNode>();
        if (start == end) {
            TreeNode aResult = new TreeNode(start);
            results.add(aResult);
            return results;
        }
        
        // using the start as the root
        List<TreeNode> subResults = generateTrees(start + 1, end);
        for (TreeNode asubResult : subResults) {
            TreeNode newResult = new TreeNode(start);
            newResult.right = asubResult;
            results.add(newResult);
        }
        
        // using the end as the root
        List<TreeNode> leftSubResults = generateTrees(start, end -1);
        for (TreeNode aLeftSubResult : leftSubResults) {
            TreeNode newResult = new TreeNode(end);
            newResult.left = aLeftSubResult;
            results.add(newResult);
        }
        // using any number from start+1 to end-1 as the root
        for (int i = start+ 1; i <= end - 1; i++){
            List<TreeNode> generalLeftSubResults = generateTrees(start, i - 1);
            List<TreeNode> generalRightSubResults = generateTrees(i+1, end);
            for (TreeNode aLeftSubResult : generalLeftSubResults) {
                for (TreeNode aRightSubResult : generalRightSubResults) {
                    TreeNode newResult = new TreeNode(i);
                    newResult.left = aLeftSubResult;
                    newResult.right = aRightSubResult;
                    results.add(newResult);
                }
            }
            
        }
        
        return results;
        
    }
    
}