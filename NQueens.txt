public class Solution {
    
	private Stack<ArrayList<Integer>> stk;
	private List<String[]> result;
	private int n;
	
	public List<String[]> solveNQueens(int n) {
		// return all possible solutions of the N-Queens problem.
		// empty positions represented by '.' Queen represented by 'Q'.
		result = new ArrayList<String[]>();
		stk = new Stack<ArrayList<Integer>>();
		this.n = n;
		if (n == 0) {
			return result;
		}		
		ArrayList<Integer> firstPosition = new ArrayList<Integer>();
		firstPosition.add(0);
		firstPosition.add(0);
		stk.push(firstPosition);
		
		while (!stk.isEmpty()) {
			// the stk represents the current status of the board.
			// the number of elements in stk is the number of queens placed.
			int currRow= stk.peek().get(0);
			int currColumn = stk.peek().get(1);
			if (currColumn == n-1) {
				// a solution is found. need to add a instance to the solution, and
				// backtrack to the next valid status.
				addASolution();
				backtrack();
			}
			else { // try to place a queen in the next column.
				int i = 0;
				while (i<n && underAttack(i, currColumn + 1)) {
					// underAttack: test whether placing a queen at i, currColumn +1, 
					// the queen will be underAttack by other queens.
					i++;
				}
				if (i==n) { 
					// reached at the end of the row, backtrack to the next possible status.
					backtrack();
				}
				else {
					ArrayList<Integer> p = new ArrayList<Integer>();
					p.add(i); p.add(currColumn+1);
					stk.push(p);
				}
			}			
		}		
		return result;		
	}
	
	public boolean underAttack(int i , int j) {
		if (stk.size() == 0) {
			return false;
		}
		for (ArrayList<Integer> aPos : stk) {
			int Pi = aPos.get(0);
			int Pj = aPos.get(1);
			if (Pi == i || Pj == j) {
				return true;
			}
			if (Math.abs(Pi-i) == Math.abs(Pj-j)) {
				return true;
			}
		}
		return false;
	}
	
	public void addASolution() {
		char[][] board = new char[n][n];
		for(int i = 0; i <n; i ++) {
			for(int j = 0; j <n; j++) {
				board[i][j] = '.';
			}
		}
		
		for (ArrayList<Integer> aPos: stk) {
			int Pi = aPos.get(0);
			int Pj = aPos.get(1);
			board[Pi][Pj] = 'Q';
		}
		String[] aResult = new String[n];
		for (int i = 0; i < n; i++) {
			aResult[i] = new String(board[i]);
		}
		result.add(aResult);		
	}
	
	public void backtrack() {
		if (stk.isEmpty()) {
			return;
		}
		int currRow = stk.peek().get(0);
		int currColumn = stk.peek().get(1);
		stk.pop();
		int nextRow = currRow + 1;
		while(nextRow < n && underAttack(nextRow, currColumn)) {
			nextRow ++;
		}
		if (nextRow == n) {
			backtrack();
		}
		else {
			ArrayList<Integer> nextPos = new ArrayList<Integer>();
			nextPos.add(nextRow);
			nextPos.add(currColumn);
			stk.push(nextPos);
		}
	}
}