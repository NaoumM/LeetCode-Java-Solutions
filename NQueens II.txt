public class Solution {
	private Stack<ArrayList<Integer>> stk;
	//private List<String[]> result;
	private int n;
	
	public int totalNQueens(int n) {
		// return all possible solutions of the N-Queens problem.
		// empty positions represented by '.' Queen represented by 'Q'.
		//result = new ArrayList<String[]>();
		stk = new Stack<ArrayList<Integer>>();
		this.n = n;
		if (n == 0) {
			return 0;
		}
		int nResult = 0;
		ArrayList<Integer> firstPosition = new ArrayList<Integer>();
		firstPosition.add(0);
		firstPosition.add(0);
		stk.push(firstPosition);
		
		
		while (!stk.isEmpty()) {
			// the stk represents the current status of the board.
			// the number of elements in stk is the number of queens placed.
			int currRow= stk.peek().get(0);
			int currColumn = stk.peek().get(1);
			if (currColumn == n-1) {
				// a solution is found. need to add a instance to the solution, and
				// backtrack to the next valid status.
				nResult++;
				backtrack();
			}
			else { // try to place a queen in the next column.
				int i = 0;
				while (i<n && underAttack(i, currColumn + 1)) {
					// underAttack: test whether placing a queen at i, currColumn +1, 
					// the queen will be underAttack by other queens.
					i++;
				}
				if (i==n) { 
					// reached at the end of the row, backtrack to the next possible status.
					backtrack();
				}
				else {
					ArrayList<Integer> p = new ArrayList<Integer>();
					p.add(i); p.add(currColumn+1);
					stk.push(p);
				}
			}			
		}		
		return nResult;
	}
	
	public boolean underAttack(int i , int j) {
		if (stk.size() == 0) {
			return false;
		}
		for (ArrayList<Integer> aPos : stk) {
			int Pi = aPos.get(0);
			int Pj = aPos.get(1);
			if (Pi == i || Pj == j) {
				return true;
			}
			if (Math.abs(Pi-i) == Math.abs(Pj-j)) {
				return true;
			}
		}
		return false;
	}
	
	public void backtrack() {
		if (stk.isEmpty()) {
			return;
		}
		int currRow = stk.peek().get(0);
		int currColumn = stk.peek().get(1);
		stk.pop();
		int nextRow = currRow + 1;
		while(nextRow < n && underAttack(nextRow, currColumn)) {
			nextRow ++;
		}
		if (nextRow == n) {
			backtrack();
		}
		else {
			ArrayList<Integer> nextPos = new ArrayList<Integer>();
			nextPos.add(nextRow);
			nextPos.add(currColumn);
			stk.push(nextPos);
		}
	}
}